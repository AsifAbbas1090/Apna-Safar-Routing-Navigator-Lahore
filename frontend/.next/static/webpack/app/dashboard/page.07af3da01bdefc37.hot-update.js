"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: function() { return /* binding */ ApiError; },\n/* harmony export */   apiUsageApi: function() { return /* binding */ apiUsageApi; },\n/* harmony export */   dashboardApi: function() { return /* binding */ dashboardApi; },\n/* harmony export */   googleMapsApi: function() { return /* binding */ googleMapsApi; },\n/* harmony export */   healthApi: function() { return /* binding */ healthApi; },\n/* harmony export */   routeApi: function() { return /* binding */ routeApi; },\n/* harmony export */   routesApi: function() { return /* binding */ routesApi; },\n/* harmony export */   savedRoutesApi: function() { return /* binding */ savedRoutesApi; },\n/* harmony export */   stopsApi: function() { return /* binding */ stopsApi; }\n/* harmony export */ });\n/**\n * API Client for Apna Safar Backend\n * Centralized API service with error handling and type safety\n */ const API_BASE_URL = \"http://localhost:3001\" || 0;\n/**\n * API Error class\n */ class ApiError extends Error {\n    constructor(message, status, response){\n        super(message);\n        this.status = status;\n        this.response = response;\n        this.name = \"ApiError\";\n    }\n}\n/**\n * Generic API request function with error handling\n */ async function apiRequest(endpoint, options) {\n    const url = \"\".concat(API_BASE_URL).concat(endpoint);\n    try {\n        const response = await fetch(url, {\n            ...options,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...options === null || options === void 0 ? void 0 : options.headers\n            }\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new ApiError(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText), response.status, errorData);\n        }\n        // Handle empty responses\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            return await response.json();\n        }\n        return {};\n    } catch (error) {\n        if (error instanceof ApiError) {\n            throw error;\n        }\n        // Network or other errors\n        throw new ApiError(error instanceof Error ? error.message : \"Network error\", 0, error);\n    }\n}\nconst routeApi = {\n    /**\n   * Plan a route from coordinates\n   */ planRoute: async (request)=>{\n        return apiRequest(\"/route/plan\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    },\n    /**\n   * Get route by stop IDs\n   */ getRouteByStops: async (from, to, preference)=>{\n        const params = new URLSearchParams({\n            from,\n            to,\n            ...preference && {\n                preference\n            }\n        });\n        return apiRequest(\"/route/routes?\".concat(params));\n    }\n};\nconst stopsApi = {\n    /**\n   * Get all stops\n   */ getAll: async ()=>{\n        return apiRequest(\"/stops\");\n    },\n    /**\n   * Get stop by ID\n   */ getById: async (id)=>{\n        return apiRequest(\"/stops/\".concat(id));\n    },\n    /**\n   * Find nearest stops\n   */ findNearest: async function(lat, lng) {\n        let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 500, limit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10;\n        const params = new URLSearchParams({\n            near: \"\".concat(lat, \",\").concat(lng),\n            radius: radius.toString(),\n            limit: limit.toString()\n        });\n        return apiRequest(\"/stops?\".concat(params));\n    }\n};\nconst routesApi = {\n    /**\n   * Get all routes\n   */ getAll: async ()=>{\n        return apiRequest(\"/routes\");\n    },\n    /**\n   * Get route by ID with stops\n   */ getById: async (id)=>{\n        return apiRequest(\"/routes/\".concat(id));\n    }\n};\n/**\n * Health check\n */ const healthApi = {\n    check: async ()=>{\n        return apiRequest(\"/health\");\n    }\n};\n/**\n * Get auth token from localStorage\n */ function getAuthToken() {\n    if (false) {}\n    // Check both possible keys for backward compatibility\n    return localStorage.getItem(\"accessToken\") || localStorage.getItem(\"auth_token\");\n}\n/**\n * Authenticated API request\n */ async function authenticatedRequest(endpoint, options) {\n    const token = getAuthToken();\n    return apiRequest(endpoint, {\n        ...options,\n        headers: {\n            ...options === null || options === void 0 ? void 0 : options.headers,\n            ...token && {\n                Authorization: \"Bearer \".concat(token)\n            }\n        }\n    });\n}\nconst dashboardApi = {\n    /**\n   * Get user dashboard statistics\n   */ getStats: async ()=>{\n        return authenticatedRequest(\"/dashboard/stats\");\n    }\n};\nconst savedRoutesApi = {\n    /**\n   * Get user's saved routes\n   */ getAll: async ()=>{\n        return authenticatedRequest(\"/routes/saved/all\");\n    },\n    /**\n   * Save a route\n   */ save: async (routeData)=>{\n        return authenticatedRequest(\"/routes/save\", {\n            method: \"POST\",\n            body: JSON.stringify(routeData)\n        });\n    },\n    /**\n   * Delete a saved route\n   */ delete: async (routeId)=>{\n        return authenticatedRequest(\"/routes/saved/\".concat(routeId), {\n            method: \"DELETE\"\n        });\n    },\n    /**\n   * Mark route as completed\n   */ complete: async (routeId, actualDurationMin)=>{\n        return authenticatedRequest(\"/routes/complete\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                routeId,\n                actualDurationMin\n            })\n        });\n    }\n};\n/**\n * Optional authenticated request - works with or without auth token\n * Used for endpoints that support optional authentication\n */ async function optionalAuthenticatedRequest(endpoint, options) {\n    const token = getAuthToken();\n    return apiRequest(endpoint, {\n        ...options,\n        headers: {\n            ...options === null || options === void 0 ? void 0 : options.headers,\n            ...token && {\n                Authorization: \"Bearer \".concat(token)\n            }\n        }\n    });\n}\n/**\n * Google Maps API\n * Note: geocode and autocomplete support optional authentication (work for guest users)\n */ const googleMapsApi = {\n    /**\n   * Geocode address to coordinates\n   * Works with or without authentication\n   */ geocode: async (address)=>{\n        return optionalAuthenticatedRequest(\"/google-maps/geocode\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                address\n            })\n        });\n    },\n    /**\n   * Reverse geocode coordinates to address\n   * Requires authentication\n   */ reverseGeocode: async (lat, lng)=>{\n        const result = await authenticatedRequest(\"/google-maps/reverse-geocode\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                lat,\n                lng\n            })\n        });\n        return result.address || \"\";\n    },\n    /**\n   * Get place autocomplete suggestions\n   * Works with or without authentication\n   */ autocomplete: async (input, sessionToken)=>{\n        return optionalAuthenticatedRequest(\"/google-maps/autocomplete\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                input,\n                sessionToken\n            })\n        });\n    },\n    /**\n   * Get directions/route\n   * Requires authentication\n   */ getDirections: async (origin, destination, waypoints)=>{\n        return authenticatedRequest(\"/google-maps/directions\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                origin,\n                destination,\n                waypoints\n            })\n        });\n    }\n};\nconst apiUsageApi = {\n    /**\n   * Get user's API usage statistics\n   */ getUsage: async ()=>{\n        return authenticatedRequest(\"/api-usage\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpLnRzPzY4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBUEkgQ2xpZW50IGZvciBBcG5hIFNhZmFyIEJhY2tlbmRcbiAqIENlbnRyYWxpemVkIEFQSSBzZXJ2aWNlIHdpdGggZXJyb3IgaGFuZGxpbmcgYW5kIHR5cGUgc2FmZXR5XG4gKi9cblxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcblxuLyoqXG4gKiBBUEkgUmVzcG9uc2Ugd3JhcHBlclxuICovXG5pbnRlcmZhY2UgQXBpUmVzcG9uc2U8VD4ge1xuICBkYXRhPzogVDtcbiAgZXJyb3I/OiBzdHJpbmc7XG4gIHN0YXR1czogbnVtYmVyO1xufVxuXG4vKipcbiAqIEFQSSBFcnJvciBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBwdWJsaWMgc3RhdHVzOiBudW1iZXIsXG4gICAgcHVibGljIHJlc3BvbnNlPzogYW55LFxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnQXBpRXJyb3InO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJpYyBBUEkgcmVxdWVzdCBmdW5jdGlvbiB3aXRoIGVycm9yIGhhbmRsaW5nXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFwaVJlcXVlc3Q8VD4oXG4gIGVuZHBvaW50OiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBSZXF1ZXN0SW5pdCxcbik6IFByb21pc2U8VD4ge1xuICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRV9VUkx9JHtlbmRwb2ludH1gO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoXG4gICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgZXJyb3JEYXRhLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZW1wdHkgcmVzcG9uc2VzXG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7fSBhcyBUO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFwaUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgXG4gICAgLy8gTmV0d29yayBvciBvdGhlciBlcnJvcnNcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdOZXR3b3JrIGVycm9yJyxcbiAgICAgIDAsXG4gICAgICBlcnJvcixcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogUm91dGUgUGxhbm5pbmcgQVBJXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGxhblJvdXRlUmVxdWVzdCB7XG4gIGZyb206IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH07XG4gIHRvOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9O1xuICBwcmVmZXJlbmNlPzogJ2Zhc3Rlc3QnIHwgJ2xlYXN0LXdhbGtpbmcnIHwgJ2xlYXN0LXRyYW5zZmVycyc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVTdGVwIHtcbiAgdHlwZTogJ3dhbGsnIHwgJ2J1cycgfCAndHJhaW4nIHwgJ21ldHJvJztcbiAgZnJvbTogc3RyaW5nO1xuICB0bzogc3RyaW5nO1xuICByb3V0ZT86IHN0cmluZztcbiAgdGltZTogbnVtYmVyO1xuICBkaXN0YW5jZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQbGFubmVkUm91dGUge1xuICBlc3RpbWF0ZWRUaW1lOiBudW1iZXI7XG4gIHRyYW5zZmVyczogbnVtYmVyO1xuICBzdGVwczogUm91dGVTdGVwW107XG59XG5cbmV4cG9ydCBjb25zdCByb3V0ZUFwaSA9IHtcbiAgLyoqXG4gICAqIFBsYW4gYSByb3V0ZSBmcm9tIGNvb3JkaW5hdGVzXG4gICAqL1xuICBwbGFuUm91dGU6IGFzeW5jIChyZXF1ZXN0OiBQbGFuUm91dGVSZXF1ZXN0KTogUHJvbWlzZTxQbGFubmVkUm91dGU+ID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdDxQbGFubmVkUm91dGU+KCcvcm91dGUvcGxhbicsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCByb3V0ZSBieSBzdG9wIElEc1xuICAgKi9cbiAgZ2V0Um91dGVCeVN0b3BzOiBhc3luYyAoXG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgcHJlZmVyZW5jZT86ICdmYXN0ZXN0JyB8ICdsZWFzdC13YWxraW5nJyB8ICdsZWFzdC10cmFuc2ZlcnMnLFxuICApOiBQcm9taXNlPFBsYW5uZWRSb3V0ZT4gPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgLi4uKHByZWZlcmVuY2UgJiYgeyBwcmVmZXJlbmNlIH0pLFxuICAgIH0pO1xuICAgIHJldHVybiBhcGlSZXF1ZXN0PFBsYW5uZWRSb3V0ZT4oYC9yb3V0ZS9yb3V0ZXM/JHtwYXJhbXN9YCk7XG4gIH0sXG59O1xuXG4vKipcbiAqIFN0b3BzIEFQSVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0b3Age1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGxpbmU/OiBzdHJpbmcgfCBudWxsO1xuICBsYXRpdHVkZTogbnVtYmVyO1xuICBsb25naXR1ZGU6IG51bWJlcjtcbiAgdHlwZTogJ0JVUycgfCAnVFJBSU4nIHwgJ01FVFJPJyB8ICdXQUxLSU5HJztcbiAgaXNTdGF0aW9uOiBib29sZWFuO1xuICBkaXN0YW5jZV9tPzogbnVtYmVyOyAvLyBBZGRlZCBieSBuZWFyZXN0IHF1ZXJ5XG59XG5cbmV4cG9ydCBjb25zdCBzdG9wc0FwaSA9IHtcbiAgLyoqXG4gICAqIEdldCBhbGwgc3RvcHNcbiAgICovXG4gIGdldEFsbDogYXN5bmMgKCk6IFByb21pc2U8U3RvcFtdPiA9PiB7XG4gICAgcmV0dXJuIGFwaVJlcXVlc3Q8U3RvcFtdPignL3N0b3BzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBzdG9wIGJ5IElEXG4gICAqL1xuICBnZXRCeUlkOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8U3RvcCB8IG51bGw+ID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdDxTdG9wIHwgbnVsbD4oYC9zdG9wcy8ke2lkfWApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIG5lYXJlc3Qgc3RvcHNcbiAgICovXG4gIGZpbmROZWFyZXN0OiBhc3luYyAoXG4gICAgbGF0OiBudW1iZXIsXG4gICAgbG5nOiBudW1iZXIsXG4gICAgcmFkaXVzOiBudW1iZXIgPSA1MDAsXG4gICAgbGltaXQ6IG51bWJlciA9IDEwLFxuICApOiBQcm9taXNlPFN0b3BbXT4gPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgbmVhcjogYCR7bGF0fSwke2xuZ31gLFxuICAgICAgcmFkaXVzOiByYWRpdXMudG9TdHJpbmcoKSxcbiAgICAgIGxpbWl0OiBsaW1pdC50b1N0cmluZygpLFxuICAgIH0pO1xuICAgIHJldHVybiBhcGlSZXF1ZXN0PFN0b3BbXT4oYC9zdG9wcz8ke3BhcmFtc31gKTtcbiAgfSxcbn07XG5cbi8qKlxuICogUm91dGVzIEFQSVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBsaW5lPzogc3RyaW5nIHwgbnVsbDtcbiAgdHJhbnNwb3J0VHlwZTogJ0JVUycgfCAnVFJBSU4nIHwgJ01FVFJPJztcbiAgY29sb3I/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgY29uc3Qgcm91dGVzQXBpID0ge1xuICAvKipcbiAgICogR2V0IGFsbCByb3V0ZXNcbiAgICovXG4gIGdldEFsbDogYXN5bmMgKCk6IFByb21pc2U8Um91dGVbXT4gPT4ge1xuICAgIHJldHVybiBhcGlSZXF1ZXN0PFJvdXRlW10+KCcvcm91dGVzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCByb3V0ZSBieSBJRCB3aXRoIHN0b3BzXG4gICAqL1xuICBnZXRCeUlkOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8Um91dGUgJiB7IHJvdXRlU3RvcHM6IGFueVtdIH0+ID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdDxSb3V0ZSAmIHsgcm91dGVTdG9wczogYW55W10gfT4oYC9yb3V0ZXMvJHtpZH1gKTtcbiAgfSxcbn07XG5cbi8qKlxuICogSGVhbHRoIGNoZWNrXG4gKi9cbmV4cG9ydCBjb25zdCBoZWFsdGhBcGkgPSB7XG4gIGNoZWNrOiBhc3luYyAoKTogUHJvbWlzZTx7IHN0YXR1czogc3RyaW5nOyB0aW1lc3RhbXA6IHN0cmluZzsgc2VydmljZTogc3RyaW5nIH0+ID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdCgnL2hlYWx0aCcpO1xuICB9LFxufTtcblxuLyoqXG4gKiBHZXQgYXV0aCB0b2tlbiBmcm9tIGxvY2FsU3RvcmFnZVxuICovXG5mdW5jdGlvbiBnZXRBdXRoVG9rZW4oKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gIC8vIENoZWNrIGJvdGggcG9zc2libGUga2V5cyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc1Rva2VuJykgfHwgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhfdG9rZW4nKTtcbn1cblxuLyoqXG4gKiBBdXRoZW50aWNhdGVkIEFQSSByZXF1ZXN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0PFQ+KFxuICBlbmRwb2ludDogc3RyaW5nLFxuICBvcHRpb25zPzogUmVxdWVzdEluaXQsXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcbiAgcmV0dXJuIGFwaVJlcXVlc3Q8VD4oZW5kcG9pbnQsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAuLi4odG9rZW4gJiYgeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9KSxcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBEYXNoYm9hcmQgQVBJXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkU3RhdHMge1xuICB0b3RhbFJvdXRlczogbnVtYmVyO1xuICB0b3RhbFJvdXRlc0NoYW5nZTogbnVtYmVyO1xuICBhdmdDb21tdXRlVGltZTogbnVtYmVyO1xuICBhdmdDb21tdXRlVGltZUNoYW5nZTogbnVtYmVyO1xuICBmYXZvcml0ZVRyYW5zcG9ydDogc3RyaW5nO1xuICBmYXZvcml0ZVRyYW5zcG9ydENvdW50OiBudW1iZXI7XG4gIHRpbWVTYXZlZEhvdXJzOiBzdHJpbmc7XG4gIHJlY2VudFJvdXRlczogQXJyYXk8e1xuICAgIGlkOiBzdHJpbmc7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHRvOiBzdHJpbmc7XG4gICAgZGF0ZTogc3RyaW5nO1xuICAgIGR1cmF0aW9uOiBzdHJpbmc7XG4gIH0+O1xufVxuXG5leHBvcnQgY29uc3QgZGFzaGJvYXJkQXBpID0ge1xuICAvKipcbiAgICogR2V0IHVzZXIgZGFzaGJvYXJkIHN0YXRpc3RpY3NcbiAgICovXG4gIGdldFN0YXRzOiBhc3luYyAoKTogUHJvbWlzZTxEYXNoYm9hcmRTdGF0cz4gPT4ge1xuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdDxEYXNoYm9hcmRTdGF0cz4oJy9kYXNoYm9hcmQvc3RhdHMnKTtcbiAgfSxcbn07XG5cbi8qKlxuICogU2F2ZWQgUm91dGVzIEFQSVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNhdmVkUm91dGUge1xuICBpZDogc3RyaW5nO1xuICBzdGFydFN0b3BJZDogc3RyaW5nO1xuICBlbmRTdG9wSWQ6IHN0cmluZztcbiAgcm91dGVJZHM6IHN0cmluZ1tdO1xuICBldGFNaW51dGVzOiBudW1iZXI7XG4gIHN0ZXBzSnNvbjogc3RyaW5nO1xuICBwcmVmZXJlbmNlPzogc3RyaW5nO1xuICB3YWxraW5nRGlzdGFuY2VNPzogbnVtYmVyO1xuICB0cmFuc2ZlcnNDb3VudD86IG51bWJlcjtcbiAgc2F2ZWROYW1lPzogc3RyaW5nO1xuICBzdGFydFN0b3A6IHsgbmFtZTogc3RyaW5nIH07XG4gIGVuZFN0b3A6IHsgbmFtZTogc3RyaW5nIH07XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3Qgc2F2ZWRSb3V0ZXNBcGkgPSB7XG4gIC8qKlxuICAgKiBHZXQgdXNlcidzIHNhdmVkIHJvdXRlc1xuICAgKi9cbiAgZ2V0QWxsOiBhc3luYyAoKTogUHJvbWlzZTxTYXZlZFJvdXRlW10+ID0+IHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3Q8U2F2ZWRSb3V0ZVtdPignL3JvdXRlcy9zYXZlZC9hbGwnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2F2ZSBhIHJvdXRlXG4gICAqL1xuICBzYXZlOiBhc3luYyAocm91dGVEYXRhOiB7XG4gICAgc3RhcnRTdG9wSWQ6IHN0cmluZztcbiAgICBlbmRTdG9wSWQ6IHN0cmluZztcbiAgICByb3V0ZUlkczogc3RyaW5nW107XG4gICAgZXRhTWludXRlczogbnVtYmVyO1xuICAgIHN0ZXBzSnNvbjogc3RyaW5nO1xuICAgIHByZWZlcmVuY2U/OiBzdHJpbmc7XG4gICAgd2Fsa2luZ0Rpc3RhbmNlTT86IG51bWJlcjtcbiAgICB0cmFuc2ZlcnNDb3VudD86IG51bWJlcjtcbiAgICBzYXZlZE5hbWU/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPFNhdmVkUm91dGU+ID0+IHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3Q8U2F2ZWRSb3V0ZT4oJy9yb3V0ZXMvc2F2ZScsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocm91dGVEYXRhKSxcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlIGEgc2F2ZWQgcm91dGVcbiAgICovXG4gIGRlbGV0ZTogYXN5bmMgKHJvdXRlSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdDx2b2lkPihgL3JvdXRlcy9zYXZlZC8ke3JvdXRlSWR9YCwge1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTWFyayByb3V0ZSBhcyBjb21wbGV0ZWRcbiAgICovXG4gIGNvbXBsZXRlOiBhc3luYyAocm91dGVJZDogc3RyaW5nLCBhY3R1YWxEdXJhdGlvbk1pbjogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0PHZvaWQ+KCcvcm91dGVzL2NvbXBsZXRlJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJvdXRlSWQsIGFjdHVhbER1cmF0aW9uTWluIH0pLFxuICAgIH0pO1xuICB9LFxufTtcblxuLyoqXG4gKiBPcHRpb25hbCBhdXRoZW50aWNhdGVkIHJlcXVlc3QgLSB3b3JrcyB3aXRoIG9yIHdpdGhvdXQgYXV0aCB0b2tlblxuICogVXNlZCBmb3IgZW5kcG9pbnRzIHRoYXQgc3VwcG9ydCBvcHRpb25hbCBhdXRoZW50aWNhdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBvcHRpb25hbEF1dGhlbnRpY2F0ZWRSZXF1ZXN0PFQ+KFxuICBlbmRwb2ludDogc3RyaW5nLFxuICBvcHRpb25zPzogUmVxdWVzdEluaXQsXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcbiAgcmV0dXJuIGFwaVJlcXVlc3Q8VD4oZW5kcG9pbnQsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAuLi4odG9rZW4gJiYgeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9KSxcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBHb29nbGUgTWFwcyBBUElcbiAqIE5vdGU6IGdlb2NvZGUgYW5kIGF1dG9jb21wbGV0ZSBzdXBwb3J0IG9wdGlvbmFsIGF1dGhlbnRpY2F0aW9uICh3b3JrIGZvciBndWVzdCB1c2VycylcbiAqL1xuZXhwb3J0IGNvbnN0IGdvb2dsZU1hcHNBcGkgPSB7XG4gIC8qKlxuICAgKiBHZW9jb2RlIGFkZHJlc3MgdG8gY29vcmRpbmF0ZXNcbiAgICogV29ya3Mgd2l0aCBvciB3aXRob3V0IGF1dGhlbnRpY2F0aW9uXG4gICAqL1xuICBnZW9jb2RlOiBhc3luYyAoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTx7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9PiA9PiB7XG4gICAgcmV0dXJuIG9wdGlvbmFsQXV0aGVudGljYXRlZFJlcXVlc3Q8eyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfT4oJy9nb29nbGUtbWFwcy9nZW9jb2RlJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGFkZHJlc3MgfSksXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldmVyc2UgZ2VvY29kZSBjb29yZGluYXRlcyB0byBhZGRyZXNzXG4gICAqIFJlcXVpcmVzIGF1dGhlbnRpY2F0aW9uXG4gICAqL1xuICByZXZlcnNlR2VvY29kZTogYXN5bmMgKGxhdDogbnVtYmVyLCBsbmc6IG51bWJlcik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlZFJlcXVlc3Q8eyBhZGRyZXNzOiBzdHJpbmcgfT4oJy9nb29nbGUtbWFwcy9yZXZlcnNlLWdlb2NvZGUnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbGF0LCBsbmcgfSksXG4gICAgfSk7XG4gICAgcmV0dXJuIChyZXN1bHQgYXMgYW55KS5hZGRyZXNzIHx8ICcnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcGxhY2UgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zXG4gICAqIFdvcmtzIHdpdGggb3Igd2l0aG91dCBhdXRoZW50aWNhdGlvblxuICAgKi9cbiAgYXV0b2NvbXBsZXRlOiBhc3luYyAoaW5wdXQ6IHN0cmluZywgc2Vzc2lvblRva2VuPzogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4gPT4ge1xuICAgIHJldHVybiBvcHRpb25hbEF1dGhlbnRpY2F0ZWRSZXF1ZXN0PGFueVtdPignL2dvb2dsZS1tYXBzL2F1dG9jb21wbGV0ZScsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbnB1dCwgc2Vzc2lvblRva2VuIH0pLFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgZGlyZWN0aW9ucy9yb3V0ZVxuICAgKiBSZXF1aXJlcyBhdXRoZW50aWNhdGlvblxuICAgKi9cbiAgZ2V0RGlyZWN0aW9uczogYXN5bmMgKFxuICAgIG9yaWdpbjogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSxcbiAgICBkZXN0aW5hdGlvbjogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSxcbiAgICB3YXlwb2ludHM/OiBBcnJheTx7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9PixcbiAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3Q8YW55PignL2dvb2dsZS1tYXBzL2RpcmVjdGlvbnMnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgb3JpZ2luLCBkZXN0aW5hdGlvbiwgd2F5cG9pbnRzIH0pLFxuICAgIH0pO1xuICB9LFxufTtcblxuLyoqXG4gKiBBUEkgVXNhZ2UgQVBJXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXBpVXNhZ2VTdGF0cyB7XG4gIGlzUHJlbWl1bTogYm9vbGVhbjtcbiAgdXNhZ2U6IHtcbiAgICBkeW5hbWljTWFwczogeyBjdXJyZW50OiBudW1iZXI7IGxpbWl0OiBudW1iZXI7IHBlcmNlbnRhZ2U6IG51bWJlciB9O1xuICAgIHBsYWNlc0F1dG9jb21wbGV0ZTogeyBjdXJyZW50OiBudW1iZXI7IGxpbWl0OiBudW1iZXI7IHBlcmNlbnRhZ2U6IG51bWJlciB9O1xuICAgIGRpcmVjdGlvbnM6IHsgY3VycmVudDogbnVtYmVyOyBsaW1pdDogbnVtYmVyOyBwZXJjZW50YWdlOiBudW1iZXIgfTtcbiAgICBnZW9jb2Rpbmc6IHsgY3VycmVudDogbnVtYmVyOyBsaW1pdDogbnVtYmVyOyBwZXJjZW50YWdlOiBudW1iZXIgfTtcbiAgICBzdGF0aWNNYXBzOiB7IGN1cnJlbnQ6IG51bWJlcjsgbGltaXQ6IG51bWJlcjsgcGVyY2VudGFnZTogbnVtYmVyIH07XG4gICAgbGFzdFJlc2V0QXQ6IHN0cmluZztcbiAgfSB8IG51bGw7XG59XG5cbmV4cG9ydCBjb25zdCBhcGlVc2FnZUFwaSA9IHtcbiAgLyoqXG4gICAqIEdldCB1c2VyJ3MgQVBJIHVzYWdlIHN0YXRpc3RpY3NcbiAgICovXG4gIGdldFVzYWdlOiBhc3luYyAoKTogUHJvbWlzZTxBcGlVc2FnZVN0YXRzPiA9PiB7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0PEFwaVVzYWdlU3RhdHM+KCcvYXBpLXVzYWdlJyk7XG4gIH0sXG59O1xuXG4iXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJBcGlFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwic3RhdHVzIiwicmVzcG9uc2UiLCJuYW1lIiwiYXBpUmVxdWVzdCIsImVuZHBvaW50Iiwib3B0aW9ucyIsInVybCIsImZldGNoIiwiaGVhZGVycyIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsImNhdGNoIiwic3RhdHVzVGV4dCIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiaW5jbHVkZXMiLCJlcnJvciIsInJvdXRlQXBpIiwicGxhblJvdXRlIiwicmVxdWVzdCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0Um91dGVCeVN0b3BzIiwiZnJvbSIsInRvIiwicHJlZmVyZW5jZSIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInN0b3BzQXBpIiwiZ2V0QWxsIiwiZ2V0QnlJZCIsImlkIiwiZmluZE5lYXJlc3QiLCJsYXQiLCJsbmciLCJyYWRpdXMiLCJsaW1pdCIsIm5lYXIiLCJ0b1N0cmluZyIsInJvdXRlc0FwaSIsImhlYWx0aEFwaSIsImNoZWNrIiwiZ2V0QXV0aFRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImF1dGhlbnRpY2F0ZWRSZXF1ZXN0IiwidG9rZW4iLCJBdXRob3JpemF0aW9uIiwiZGFzaGJvYXJkQXBpIiwiZ2V0U3RhdHMiLCJzYXZlZFJvdXRlc0FwaSIsInNhdmUiLCJyb3V0ZURhdGEiLCJkZWxldGUiLCJyb3V0ZUlkIiwiY29tcGxldGUiLCJhY3R1YWxEdXJhdGlvbk1pbiIsIm9wdGlvbmFsQXV0aGVudGljYXRlZFJlcXVlc3QiLCJnb29nbGVNYXBzQXBpIiwiZ2VvY29kZSIsImFkZHJlc3MiLCJyZXZlcnNlR2VvY29kZSIsInJlc3VsdCIsImF1dG9jb21wbGV0ZSIsImlucHV0Iiwic2Vzc2lvblRva2VuIiwiZ2V0RGlyZWN0aW9ucyIsIm9yaWdpbiIsImRlc3RpbmF0aW9uIiwid2F5cG9pbnRzIiwiYXBpVXNhZ2VBcGkiLCJnZXRVc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAuthToken: function() { return /* binding */ clearAuthToken; },\n/* harmony export */   getAuthToken: function() { return /* binding */ getAuthToken; },\n/* harmony export */   getCurrentUser: function() { return /* binding */ getCurrentUser; },\n/* harmony export */   setAuthToken: function() { return /* binding */ setAuthToken; },\n/* harmony export */   signIn: function() { return /* binding */ signIn; },\n/* harmony export */   signInWithGoogle: function() { return /* binding */ signInWithGoogle; },\n/* harmony export */   signUp: function() { return /* binding */ signUp; }\n/* harmony export */ });\n/**\n * Frontend Auth Utilities\n * Handles authentication state and API calls\n */ const API_BASE_URL = \"http://localhost:3001\" || 0;\n/**\n * Sign up with email and password\n */ async function signUp(email, password, name, occupation) {\n    const response = await fetch(\"\".concat(API_BASE_URL, \"/auth/signup\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            email,\n            password,\n            name,\n            occupation\n        })\n    });\n    if (!response.ok) {\n        const error = await response.json().catch(()=>({}));\n        throw new Error(error.message || \"Sign up failed\");\n    }\n    return response.json();\n}\n/**\n * Sign in with email and password\n */ async function signIn(email, password) {\n    const response = await fetch(\"\".concat(API_BASE_URL, \"/auth/signin\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            email,\n            password\n        })\n    });\n    if (!response.ok) {\n        const error = await response.json().catch(()=>({}));\n        throw new Error(error.message || \"Sign in failed\");\n    }\n    return response.json();\n}\n/**\n * Sign in/Sign up with Google\n * Note: In production, you'll need to implement Google OAuth flow\n * This is a placeholder that expects a Google access token\n */ async function signInWithGoogle(accessToken, name, occupation) {\n    const response = await fetch(\"\".concat(API_BASE_URL, \"/auth/google\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            accessToken,\n            name,\n            occupation\n        })\n    });\n    if (!response.ok) {\n        const error = await response.json().catch(()=>({}));\n        throw new Error(error.message || \"Google authentication failed\");\n    }\n    return response.json();\n}\n/**\n * Get current user\n */ async function getCurrentUser(token) {\n    const response = await fetch(\"\".concat(API_BASE_URL, \"/auth/me\"), {\n        method: \"GET\",\n        headers: {\n            \"Authorization\": \"Bearer \".concat(token),\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to get user\");\n    }\n    return response.json();\n}\n/**\n * Store auth token in localStorage\n */ function setAuthToken(token) {\n    if (true) {\n        localStorage.setItem(\"auth_token\", token);\n    }\n}\n/**\n * Get auth token from localStorage\n */ function getAuthToken() {\n    if (true) {\n        return localStorage.getItem(\"auth_token\");\n    }\n    return null;\n}\n/**\n * Remove auth token from localStorage\n */ function clearAuthToken() {\n    if (true) {\n        localStorage.removeItem(\"auth_token\");\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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InNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRnJvbnRlbmQgQXV0aCBVdGlsaXRpZXNcbiAqIEhhbmRsZXMgYXV0aGVudGljYXRpb24gc3RhdGUgYW5kIEFQSSBjYWxsc1xuICovXG5cbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsO1xuICBvY2N1cGF0aW9uPzogc3RyaW5nIHwgbnVsbDtcbiAgaXNQcmVtaXVtPzogYm9vbGVhbjtcbiAgcHJlbWl1bUV4cGlyZXNBdD86IHN0cmluZyB8IG51bGw7XG4gIHN1YnNjcmlwdGlvblBsYW4/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhSZXNwb25zZSB7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgdXNlcjogVXNlcjtcbiAgYWNjZXNzVG9rZW46IHN0cmluZztcbiAgcmVmcmVzaFRva2VuOiBzdHJpbmc7XG59XG5cbi8qKlxuICogU2lnbiB1cCB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnblVwKFxuICBlbWFpbDogc3RyaW5nLFxuICBwYXNzd29yZDogc3RyaW5nLFxuICBuYW1lPzogc3RyaW5nLFxuICBvY2N1cGF0aW9uPzogc3RyaW5nLFxuKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2F1dGgvc2lnbnVwYCwge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBlbWFpbCxcbiAgICAgIHBhc3N3b3JkLFxuICAgICAgbmFtZSxcbiAgICAgIG9jY3VwYXRpb24sXG4gICAgfSksXG4gIH0pO1xuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnU2lnbiB1cCBmYWlsZWQnKTtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5cbi8qKlxuICogU2lnbiBpbiB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXV0aC9zaWduaW5gLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGVtYWlsLFxuICAgICAgcGFzc3dvcmQsXG4gICAgfSksXG4gIH0pO1xuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnU2lnbiBpbiBmYWlsZWQnKTtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5cbi8qKlxuICogU2lnbiBpbi9TaWduIHVwIHdpdGggR29vZ2xlXG4gKiBOb3RlOiBJbiBwcm9kdWN0aW9uLCB5b3UnbGwgbmVlZCB0byBpbXBsZW1lbnQgR29vZ2xlIE9BdXRoIGZsb3dcbiAqIFRoaXMgaXMgYSBwbGFjZWhvbGRlciB0aGF0IGV4cGVjdHMgYSBHb29nbGUgYWNjZXNzIHRva2VuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoR29vZ2xlKFxuICBhY2Nlc3NUb2tlbjogc3RyaW5nLFxuICBuYW1lPzogc3RyaW5nLFxuICBvY2N1cGF0aW9uPzogc3RyaW5nLFxuKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2F1dGgvZ29vZ2xlYCwge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBhY2Nlc3NUb2tlbixcbiAgICAgIG5hbWUsXG4gICAgICBvY2N1cGF0aW9uLFxuICAgIH0pLFxuICB9KTtcblxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgJ0dvb2dsZSBhdXRoZW50aWNhdGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgdXNlclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXIodG9rZW46IHN0cmluZyk6IFByb21pc2U8VXNlcj4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXV0aC9tZWAsIHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIH0sXG4gIH0pO1xuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgdXNlcicpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbn1cblxuLyoqXG4gKiBTdG9yZSBhdXRoIHRva2VuIGluIGxvY2FsU3RvcmFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0QXV0aFRva2VuKHRva2VuOiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhfdG9rZW4nLCB0b2tlbik7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYXV0aCB0b2tlbiBmcm9tIGxvY2FsU3RvcmFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXV0aFRva2VuKCk6IHN0cmluZyB8IG51bGwge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhfdG9rZW4nKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYXV0aCB0b2tlbiBmcm9tIGxvY2FsU3RvcmFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBdXRoVG9rZW4oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoX3Rva2VuJyk7XG4gIH1cbn1cblxuIl0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwic2lnblVwIiwiZW1haWwiLCJwYXNzd29yZCIsIm5hbWUiLCJvY2N1cGF0aW9uIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiZXJyb3IiLCJqc29uIiwiY2F0Y2giLCJFcnJvciIsIm1lc3NhZ2UiLCJzaWduSW4iLCJzaWduSW5XaXRoR29vZ2xlIiwiYWNjZXNzVG9rZW4iLCJnZXRDdXJyZW50VXNlciIsInRva2VuIiwic2V0QXV0aFRva2VuIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImdldEF1dGhUb2tlbiIsImdldEl0ZW0iLCJjbGVhckF1dGhUb2tlbiIsInJlbW92ZUl0ZW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth.ts\n"));

/***/ })

});