"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: function() { return /* binding */ ApiError; },\n/* harmony export */   apiUsageApi: function() { return /* binding */ apiUsageApi; },\n/* harmony export */   dashboardApi: function() { return /* binding */ dashboardApi; },\n/* harmony export */   googleMapsApi: function() { return /* binding */ googleMapsApi; },\n/* harmony export */   healthApi: function() { return /* binding */ healthApi; },\n/* harmony export */   routeApi: function() { return /* binding */ routeApi; },\n/* harmony export */   routesApi: function() { return /* binding */ routesApi; },\n/* harmony export */   savedRoutesApi: function() { return /* binding */ savedRoutesApi; },\n/* harmony export */   stopsApi: function() { return /* binding */ stopsApi; }\n/* harmony export */ });\n/**\n * API Client for Apna Safar Backend\n * Centralized API service with error handling and type safety\n */ const API_BASE_URL = \"http://localhost:3001\" || 0;\n// #region agent log\nfetch(\"http://127.0.0.1:7242/ingest/e959c8d5-c5d1-4ea5-b92d-9048dc30ea1b\", {\n    method: \"POST\",\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n        location: \"api.ts:6\",\n        message: \"API_BASE_URL initialized\",\n        data: {\n            apiBaseUrl: API_BASE_URL,\n            envVar: \"http://localhost:3001\"\n        },\n        timestamp: Date.now(),\n        sessionId: \"debug-session\",\n        runId: \"run1\",\n        hypothesisId: \"C\"\n    })\n}).catch(()=>{});\n/**\n * API Error class\n */ class ApiError extends Error {\n    constructor(message, status, response){\n        super(message);\n        this.status = status;\n        this.response = response;\n        this.name = \"ApiError\";\n    }\n}\n/**\n * Generic API request function with error handling\n */ async function apiRequest(endpoint, options) {\n    const url = \"\".concat(API_BASE_URL).concat(endpoint);\n    try {\n        const response = await fetch(url, {\n            ...options,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...options === null || options === void 0 ? void 0 : options.headers\n            }\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new ApiError(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText), response.status, errorData);\n        }\n        // Handle empty responses\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            return await response.json();\n        }\n        return {};\n    } catch (error) {\n        if (error instanceof ApiError) {\n            throw error;\n        }\n        // Network or other errors\n        throw new ApiError(error instanceof Error ? error.message : \"Network error\", 0, error);\n    }\n}\nconst routeApi = {\n    /**\n   * Plan a route from coordinates\n   */ planRoute: async (request)=>{\n        return apiRequest(\"/route/plan\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    },\n    /**\n   * Get route by stop IDs\n   */ getRouteByStops: async (from, to, preference)=>{\n        const params = new URLSearchParams({\n            from,\n            to,\n            ...preference && {\n                preference\n            }\n        });\n        return apiRequest(\"/route/routes?\".concat(params));\n    }\n};\nconst stopsApi = {\n    /**\n   * Get all stops\n   */ getAll: async ()=>{\n        return apiRequest(\"/stops\");\n    },\n    /**\n   * Get stop by ID\n   */ getById: async (id)=>{\n        return apiRequest(\"/stops/\".concat(id));\n    },\n    /**\n   * Find nearest stops\n   */ findNearest: async function(lat, lng) {\n        let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 500, limit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10;\n        const params = new URLSearchParams({\n            near: \"\".concat(lat, \",\").concat(lng),\n            radius: radius.toString(),\n            limit: limit.toString()\n        });\n        return apiRequest(\"/stops?\".concat(params));\n    }\n};\nconst routesApi = {\n    /**\n   * Get all routes\n   */ getAll: async ()=>{\n        return apiRequest(\"/routes\");\n    },\n    /**\n   * Get route by ID with stops\n   */ getById: async (id)=>{\n        return apiRequest(\"/routes/\".concat(id));\n    }\n};\n/**\n * Health check\n */ const healthApi = {\n    check: async ()=>{\n        return apiRequest(\"/health\");\n    }\n};\n/**\n * Get auth token from localStorage\n */ function getAuthToken() {\n    if (false) {}\n    // Check both possible keys for backward compatibility\n    return localStorage.getItem(\"accessToken\") || localStorage.getItem(\"auth_token\");\n}\n/**\n * Authenticated API request\n */ async function authenticatedRequest(endpoint, options) {\n    const token = getAuthToken();\n    return apiRequest(endpoint, {\n        ...options,\n        headers: {\n            ...options === null || options === void 0 ? void 0 : options.headers,\n            ...token && {\n                Authorization: \"Bearer \".concat(token)\n            }\n        }\n    });\n}\nconst dashboardApi = {\n    /**\n   * Get user dashboard statistics\n   */ getStats: async ()=>{\n        return authenticatedRequest(\"/dashboard/stats\");\n    }\n};\nconst savedRoutesApi = {\n    /**\n   * Get user's saved routes\n   */ getAll: async ()=>{\n        return authenticatedRequest(\"/routes/saved/all\");\n    },\n    /**\n   * Save a route\n   */ save: async (routeData)=>{\n        return authenticatedRequest(\"/routes/save\", {\n            method: \"POST\",\n            body: JSON.stringify(routeData)\n        });\n    },\n    /**\n   * Delete a saved route\n   */ delete: async (routeId)=>{\n        return authenticatedRequest(\"/routes/saved/\".concat(routeId), {\n            method: \"DELETE\"\n        });\n    },\n    /**\n   * Mark route as completed\n   */ complete: async (routeId, actualDurationMin)=>{\n        return authenticatedRequest(\"/routes/complete\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                routeId,\n                actualDurationMin\n            })\n        });\n    }\n};\n/**\n * Optional authenticated request - works with or without auth token\n * Used for endpoints that support optional authentication\n */ async function optionalAuthenticatedRequest(endpoint, options) {\n    const token = getAuthToken();\n    return apiRequest(endpoint, {\n        ...options,\n        headers: {\n            ...options === null || options === void 0 ? void 0 : options.headers,\n            ...token && {\n                Authorization: \"Bearer \".concat(token)\n            }\n        }\n    });\n}\n/**\n * Google Maps API\n * Note: geocode and autocomplete support optional authentication (work for guest users)\n */ const googleMapsApi = {\n    /**\n   * Geocode address to coordinates\n   * Works with or without authentication\n   */ geocode: async (address, geocodeOptions)=>{\n        var _geocodeOptions_locationBias, _geocodeOptions_componentRestrictions;\n        // Convert to backend format\n        const backendOptions = {\n            address\n        };\n        if (geocodeOptions === null || geocodeOptions === void 0 ? void 0 : (_geocodeOptions_locationBias = geocodeOptions.locationBias) === null || _geocodeOptions_locationBias === void 0 ? void 0 : _geocodeOptions_locationBias.circle) {\n            backendOptions.location = {\n                lat: geocodeOptions.locationBias.circle.center.lat,\n                lng: geocodeOptions.locationBias.circle.center.lng\n            };\n            backendOptions.radius = geocodeOptions.locationBias.circle.radius;\n        }\n        if (geocodeOptions === null || geocodeOptions === void 0 ? void 0 : (_geocodeOptions_componentRestrictions = geocodeOptions.componentRestrictions) === null || _geocodeOptions_componentRestrictions === void 0 ? void 0 : _geocodeOptions_componentRestrictions.country) {\n            backendOptions.components = \"country:\".concat(geocodeOptions.componentRestrictions.country);\n        }\n        return optionalAuthenticatedRequest(\"/google-maps/geocode\", {\n            method: \"POST\",\n            body: JSON.stringify(backendOptions)\n        });\n    },\n    /**\n   * Reverse geocode coordinates to address\n   * Works with or without authentication\n   */ reverseGeocode: async (lat, lng)=>{\n        const result = await optionalAuthenticatedRequest(\"/google-maps/reverse-geocode\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                lat,\n                lng\n            })\n        });\n        return result.address || \"\";\n    },\n    /**\n   * Get place autocomplete suggestions\n   * Works with or without authentication\n   */ autocomplete: async (input, sessionToken, options)=>{\n        var _options_locationBias, _options_componentRestrictions;\n        // Convert to backend format\n        const backendOptions = {};\n        if (options === null || options === void 0 ? void 0 : (_options_locationBias = options.locationBias) === null || _options_locationBias === void 0 ? void 0 : _options_locationBias.circle) {\n            backendOptions.location = {\n                lat: options.locationBias.circle.center.lat,\n                lng: options.locationBias.circle.center.lng\n            };\n            backendOptions.radius = options.locationBias.circle.radius;\n        }\n        if (options === null || options === void 0 ? void 0 : (_options_componentRestrictions = options.componentRestrictions) === null || _options_componentRestrictions === void 0 ? void 0 : _options_componentRestrictions.country) {\n            backendOptions.components = \"country:\".concat(options.componentRestrictions.country);\n        }\n        return optionalAuthenticatedRequest(\"/google-maps/autocomplete\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                input,\n                sessionToken,\n                ...backendOptions\n            })\n        });\n    },\n    /**\n   * Get directions/route\n   * Requires authentication\n   */ getDirections: async (origin, destination, waypoints)=>{\n        return authenticatedRequest(\"/google-maps/directions\", {\n            method: \"POST\",\n            body: JSON.stringify({\n                origin,\n                destination,\n                waypoints\n            })\n        });\n    }\n};\nconst apiUsageApi = {\n    /**\n   * Get user's API usage statistics\n   */ getUsage: async ()=>{\n        return authenticatedRequest(\"/api-usage\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBRUQsTUFBTUEsZUFBZUMsdUJBQStCLElBQUk7QUFDeEQsb0JBQW9CO0FBQ3BCRyxNQUFNLHFFQUFvRTtJQUFDQyxRQUFPO0lBQU9DLFNBQVE7UUFBQyxnQkFBZTtJQUFrQjtJQUFFQyxNQUFLQyxLQUFLQyxTQUFTLENBQUM7UUFBQ0MsVUFBUztRQUFXQyxTQUFRO1FBQTJCQyxNQUFLO1lBQUNDLFlBQVdiO1lBQWFjLFFBQU9iLHVCQUErQjtRQUFBO1FBQUVjLFdBQVVDLEtBQUtDLEdBQUc7UUFBR0MsV0FBVTtRQUFnQkMsT0FBTTtRQUFPQyxjQUFhO0lBQUc7QUFBRSxHQUFHQyxLQUFLLENBQUMsS0FBSztBQVluWDs7Q0FFQyxHQUNNLE1BQU1DLGlCQUFpQkM7SUFDNUJDLFlBQ0ViLE9BQWUsRUFDZixNQUFxQixFQUNyQixRQUFxQixDQUNyQjtRQUNBLEtBQUssQ0FBQ0E7YUFIQ2MsU0FBQUE7YUFDQUMsV0FBQUE7UUFHUCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELGVBQWVDLFdBQ2JDLFFBQWdCLEVBQ2hCQyxPQUFxQjtJQUVyQixNQUFNQyxNQUFNLEdBQWtCRixPQUFmN0IsY0FBd0IsT0FBVDZCO0lBRTlCLElBQUk7UUFDRixNQUFNSCxXQUFXLE1BQU10QixNQUFNMkIsS0FBSztZQUNoQyxHQUFHRCxPQUFPO1lBQ1Z4QixTQUFTO2dCQUNQLGdCQUFnQjttQkFDYndCLG9CQUFBQSw4QkFBQUEsUUFBU3hCLE9BQU87WUFDckI7UUFDRjtRQUVBLElBQUksQ0FBQ29CLFNBQVNNLEVBQUUsRUFBRTtZQUNoQixNQUFNQyxZQUFZLE1BQU1QLFNBQVNRLElBQUksR0FBR2IsS0FBSyxDQUFDLElBQU8sRUFBQztZQUN0RCxNQUFNLElBQUlDLFNBQ1JXLFVBQVV0QixPQUFPLElBQUksUUFBNEJlLE9BQXBCQSxTQUFTRCxNQUFNLEVBQUMsTUFBd0IsT0FBcEJDLFNBQVNTLFVBQVUsR0FDcEVULFNBQVNELE1BQU0sRUFDZlE7UUFFSjtRQUVBLHlCQUF5QjtRQUN6QixNQUFNRyxjQUFjVixTQUFTcEIsT0FBTyxDQUFDK0IsR0FBRyxDQUFDO1FBQ3pDLElBQUlELGVBQWVBLFlBQVlFLFFBQVEsQ0FBQyxxQkFBcUI7WUFDM0QsT0FBTyxNQUFNWixTQUFTUSxJQUFJO1FBQzVCO1FBRUEsT0FBTyxDQUFDO0lBQ1YsRUFBRSxPQUFPSyxPQUFPO1FBQ2QsSUFBSUEsaUJBQWlCakIsVUFBVTtZQUM3QixNQUFNaUI7UUFDUjtRQUVBLDBCQUEwQjtRQUMxQixNQUFNLElBQUlqQixTQUNSaUIsaUJBQWlCaEIsUUFBUWdCLE1BQU01QixPQUFPLEdBQUcsaUJBQ3pDLEdBQ0E0QjtJQUVKO0FBQ0Y7QUE2Qk8sTUFBTUMsV0FBVztJQUN0Qjs7R0FFQyxHQUNEQyxXQUFXLE9BQU9DO1FBQ2hCLE9BQU9kLFdBQXlCLGVBQWU7WUFDN0N2QixRQUFRO1lBQ1JFLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ2lDO1FBQ3ZCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEQyxpQkFBaUIsT0FDZkMsTUFDQUMsSUFDQUM7UUFFQSxNQUFNQyxTQUFTLElBQUlDLGdCQUFnQjtZQUNqQ0o7WUFDQUM7WUFDQSxHQUFJQyxjQUFjO2dCQUFFQTtZQUFXLENBQUM7UUFDbEM7UUFDQSxPQUFPbEIsV0FBeUIsaUJBQXdCLE9BQVBtQjtJQUNuRDtBQUNGLEVBQUU7QUFnQkssTUFBTUUsV0FBVztJQUN0Qjs7R0FFQyxHQUNEQyxRQUFRO1FBQ04sT0FBT3RCLFdBQW1CO0lBQzVCO0lBRUE7O0dBRUMsR0FDRHVCLFNBQVMsT0FBT0M7UUFDZCxPQUFPeEIsV0FBd0IsVUFBYSxPQUFId0I7SUFDM0M7SUFFQTs7R0FFQyxHQUNEQyxhQUFhLGVBQ1hDLEtBQ0FDO1lBQ0FDLDBFQUFpQixLQUNqQkMseUVBQWdCO1FBRWhCLE1BQU1WLFNBQVMsSUFBSUMsZ0JBQWdCO1lBQ2pDVSxNQUFNLEdBQVVILE9BQVBELEtBQUksS0FBTyxPQUFKQztZQUNoQkMsUUFBUUEsT0FBT0csUUFBUTtZQUN2QkYsT0FBT0EsTUFBTUUsUUFBUTtRQUN2QjtRQUNBLE9BQU8vQixXQUFtQixVQUFpQixPQUFQbUI7SUFDdEM7QUFDRixFQUFFO0FBYUssTUFBTWEsWUFBWTtJQUN2Qjs7R0FFQyxHQUNEVixRQUFRO1FBQ04sT0FBT3RCLFdBQW9CO0lBQzdCO0lBRUE7O0dBRUMsR0FDRHVCLFNBQVMsT0FBT0M7UUFDZCxPQUFPeEIsV0FBMEMsV0FBYyxPQUFId0I7SUFDOUQ7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNUyxZQUFZO0lBQ3ZCQyxPQUFPO1FBQ0wsT0FBT2xDLFdBQVc7SUFDcEI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDRCxTQUFTbUM7SUFDUCxJQUFJLEtBQWtCLEVBQWEsRUFBWTtJQUMvQyxzREFBc0Q7SUFDdEQsT0FBT0MsYUFBYUMsT0FBTyxDQUFDLGtCQUFrQkQsYUFBYUMsT0FBTyxDQUFDO0FBQ3JFO0FBRUE7O0NBRUMsR0FDRCxlQUFlQyxxQkFDYnJDLFFBQWdCLEVBQ2hCQyxPQUFxQjtJQUVyQixNQUFNcUMsUUFBUUo7SUFDZCxPQUFPbkMsV0FBY0MsVUFBVTtRQUM3QixHQUFHQyxPQUFPO1FBQ1Z4QixTQUFTO2VBQ0p3QixvQkFBQUEsOEJBQUFBLFFBQVN4QixPQUFPO1lBQ25CLEdBQUk2RCxTQUFTO2dCQUFFQyxlQUFlLFVBQWdCLE9BQU5EO1lBQVEsQ0FBQztRQUNuRDtJQUNGO0FBQ0Y7QUFzQk8sTUFBTUUsZUFBZTtJQUMxQjs7R0FFQyxHQUNEQyxVQUFVO1FBQ1IsT0FBT0oscUJBQXFDO0lBQzlDO0FBQ0YsRUFBRTtBQXFCSyxNQUFNSyxpQkFBaUI7SUFDNUI7O0dBRUMsR0FDRHJCLFFBQVE7UUFDTixPQUFPZ0IscUJBQW1DO0lBQzVDO0lBRUE7O0dBRUMsR0FDRE0sTUFBTSxPQUFPQztRQVdYLE9BQU9QLHFCQUFpQyxnQkFBZ0I7WUFDdEQ3RCxRQUFRO1lBQ1JFLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ2dFO1FBQ3ZCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEQyxRQUFRLE9BQU9DO1FBQ2IsT0FBT1QscUJBQTJCLGlCQUF5QixPQUFSUyxVQUFXO1lBQzVEdEUsUUFBUTtRQUNWO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEdUUsVUFBVSxPQUFPRCxTQUFpQkU7UUFDaEMsT0FBT1gscUJBQTJCLG9CQUFvQjtZQUNwRDdELFFBQVE7WUFDUkUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO2dCQUFFa0U7Z0JBQVNFO1lBQWtCO1FBQ3BEO0lBQ0Y7QUFDRixFQUFFO0FBRUY7OztDQUdDLEdBQ0QsZUFBZUMsNkJBQ2JqRCxRQUFnQixFQUNoQkMsT0FBcUI7SUFFckIsTUFBTXFDLFFBQVFKO0lBQ2QsT0FBT25DLFdBQWNDLFVBQVU7UUFDN0IsR0FBR0MsT0FBTztRQUNWeEIsU0FBUztlQUNKd0Isb0JBQUFBLDhCQUFBQSxRQUFTeEIsT0FBTztZQUNuQixHQUFJNkQsU0FBUztnQkFBRUMsZUFBZSxVQUFnQixPQUFORDtZQUFRLENBQUM7UUFDbkQ7SUFDRjtBQUNGO0FBRUE7OztDQUdDLEdBQ00sTUFBTVksZ0JBQWdCO0lBQzNCOzs7R0FHQyxHQUNEQyxTQUFTLE9BQ1BDLFNBQ0FDO1lBT0lBLDhCQU9BQTtRQVRKLDRCQUE0QjtRQUM1QixNQUFNQyxpQkFBc0I7WUFBRUY7UUFBUTtRQUN0QyxJQUFJQywyQkFBQUEsc0NBQUFBLCtCQUFBQSxlQUFnQkUsWUFBWSxjQUE1QkYsbURBQUFBLDZCQUE4QkcsTUFBTSxFQUFFO1lBQ3hDRixlQUFlekUsUUFBUSxHQUFHO2dCQUN4QjRDLEtBQUs0QixlQUFlRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDaEMsR0FBRztnQkFDbERDLEtBQUsyQixlQUFlRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDL0IsR0FBRztZQUNwRDtZQUNBNEIsZUFBZTNCLE1BQU0sR0FBRzBCLGVBQWVFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDN0IsTUFBTTtRQUNuRTtRQUNBLElBQUkwQiwyQkFBQUEsc0NBQUFBLHdDQUFBQSxlQUFnQksscUJBQXFCLGNBQXJDTCw0REFBQUEsc0NBQXVDTSxPQUFPLEVBQUU7WUFDbERMLGVBQWVNLFVBQVUsR0FBRyxXQUF3RCxPQUE3Q1AsZUFBZUsscUJBQXFCLENBQUNDLE9BQU87UUFDckY7UUFFQSxPQUFPViw2QkFBMkQsd0JBQXdCO1lBQ3hGekUsUUFBUTtZQUNSRSxNQUFNQyxLQUFLQyxTQUFTLENBQUMwRTtRQUN2QjtJQUNGO0lBRUE7OztHQUdDLEdBQ0RPLGdCQUFnQixPQUFPcEMsS0FBYUM7UUFDbEMsTUFBTW9DLFNBQVMsTUFBTWIsNkJBQWtELGdDQUFnQztZQUNyR3pFLFFBQVE7WUFDUkUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO2dCQUFFNkM7Z0JBQUtDO1lBQUk7UUFDbEM7UUFDQSxPQUFPLE9BQWdCMEIsT0FBTyxJQUFJO0lBQ3BDO0lBRUE7OztHQUdDLEdBQ0RXLGNBQWMsT0FDWkMsT0FDQUMsY0FDQWhFO1lBT0lBLHVCQU9BQTtRQVRKLDRCQUE0QjtRQUM1QixNQUFNcUQsaUJBQXNCLENBQUM7UUFDN0IsSUFBSXJELG9CQUFBQSwrQkFBQUEsd0JBQUFBLFFBQVNzRCxZQUFZLGNBQXJCdEQsNENBQUFBLHNCQUF1QnVELE1BQU0sRUFBRTtZQUNqQ0YsZUFBZXpFLFFBQVEsR0FBRztnQkFDeEI0QyxLQUFLeEIsUUFBUXNELFlBQVksQ0FBQ0MsTUFBTSxDQUFDQyxNQUFNLENBQUNoQyxHQUFHO2dCQUMzQ0MsS0FBS3pCLFFBQVFzRCxZQUFZLENBQUNDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDL0IsR0FBRztZQUM3QztZQUNBNEIsZUFBZTNCLE1BQU0sR0FBRzFCLFFBQVFzRCxZQUFZLENBQUNDLE1BQU0sQ0FBQzdCLE1BQU07UUFDNUQ7UUFDQSxJQUFJMUIsb0JBQUFBLCtCQUFBQSxpQ0FBQUEsUUFBU3lELHFCQUFxQixjQUE5QnpELHFEQUFBQSwrQkFBZ0MwRCxPQUFPLEVBQUU7WUFDM0NMLGVBQWVNLFVBQVUsR0FBRyxXQUFpRCxPQUF0QzNELFFBQVF5RCxxQkFBcUIsQ0FBQ0MsT0FBTztRQUM5RTtRQUVBLE9BQU9WLDZCQUFvQyw2QkFBNkI7WUFDdEV6RSxRQUFRO1lBQ1JFLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztnQkFBRW9GO2dCQUFPQztnQkFBYyxHQUFHWCxjQUFjO1lBQUM7UUFDaEU7SUFDRjtJQUVBOzs7R0FHQyxHQUNEWSxlQUFlLE9BQ2JDLFFBQ0FDLGFBQ0FDO1FBRUEsT0FBT2hDLHFCQUEwQiwyQkFBMkI7WUFDMUQ3RCxRQUFRO1lBQ1JFLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztnQkFBRXVGO2dCQUFRQztnQkFBYUM7WUFBVTtRQUN4RDtJQUNGO0FBQ0YsRUFBRTtBQWlCSyxNQUFNQyxjQUFjO0lBQ3pCOztHQUVDLEdBQ0RDLFVBQVU7UUFDUixPQUFPbEMscUJBQW9DO0lBQzdDO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpLnRzPzY4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBUEkgQ2xpZW50IGZvciBBcG5hIFNhZmFyIEJhY2tlbmRcbiAqIENlbnRyYWxpemVkIEFQSSBzZXJ2aWNlIHdpdGggZXJyb3IgaGFuZGxpbmcgYW5kIHR5cGUgc2FmZXR5XG4gKi9cblxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcbi8vICNyZWdpb24gYWdlbnQgbG9nXG5mZXRjaCgnaHR0cDovLzEyNy4wLjAuMTo3MjQyL2luZ2VzdC9lOTU5YzhkNS1jNWQxLTRlYTUtYjkyZC05MDQ4ZGMzMGVhMWInLHttZXRob2Q6J1BPU1QnLGhlYWRlcnM6eydDb250ZW50LVR5cGUnOidhcHBsaWNhdGlvbi9qc29uJ30sYm9keTpKU09OLnN0cmluZ2lmeSh7bG9jYXRpb246J2FwaS50czo2JyxtZXNzYWdlOidBUElfQkFTRV9VUkwgaW5pdGlhbGl6ZWQnLGRhdGE6e2FwaUJhc2VVcmw6QVBJX0JBU0VfVVJMLGVudlZhcjpwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMfSx0aW1lc3RhbXA6RGF0ZS5ub3coKSxzZXNzaW9uSWQ6J2RlYnVnLXNlc3Npb24nLHJ1bklkOidydW4xJyxoeXBvdGhlc2lzSWQ6J0MnfSl9KS5jYXRjaCgoKT0+e30pO1xuLy8gI2VuZHJlZ2lvblxuXG4vKipcbiAqIEFQSSBSZXNwb25zZSB3cmFwcGVyXG4gKi9cbmludGVyZmFjZSBBcGlSZXNwb25zZTxUPiB7XG4gIGRhdGE/OiBUO1xuICBlcnJvcj86IHN0cmluZztcbiAgc3RhdHVzOiBudW1iZXI7XG59XG5cbi8qKlxuICogQVBJIEVycm9yIGNsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBBcGlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHB1YmxpYyBzdGF0dXM6IG51bWJlcixcbiAgICBwdWJsaWMgcmVzcG9uc2U/OiBhbnksXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdBcGlFcnJvcic7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmljIEFQSSByZXF1ZXN0IGZ1bmN0aW9uIHdpdGggZXJyb3IgaGFuZGxpbmdcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBpUmVxdWVzdDxUPihcbiAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgb3B0aW9ucz86IFJlcXVlc3RJbml0LFxuKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IHVybCA9IGAke0FQSV9CQVNFX1VSTH0ke2VuZHBvaW50fWA7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihcbiAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBlcnJvckRhdGEsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBlbXB0eSByZXNwb25zZXNcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHt9IGFzIFQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXBpRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBcbiAgICAvLyBOZXR3b3JrIG9yIG90aGVyIGVycm9yc1xuICAgIHRocm93IG5ldyBBcGlFcnJvcihcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ05ldHdvcmsgZXJyb3InLFxuICAgICAgMCxcbiAgICAgIGVycm9yLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBSb3V0ZSBQbGFubmluZyBBUElcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQbGFuUm91dGVSZXF1ZXN0IHtcbiAgZnJvbTogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfTtcbiAgdG86IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH07XG4gIHByZWZlcmVuY2U/OiAnZmFzdGVzdCcgfCAnbGVhc3Qtd2Fsa2luZycgfCAnbGVhc3QtdHJhbnNmZXJzJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVN0ZXAge1xuICB0eXBlOiAnd2FsaycgfCAnYnVzJyB8ICd0cmFpbicgfCAnbWV0cm8nIHwgJ29yYW5nZV9saW5lJyB8ICdmZWVkZXInO1xuICBmcm9tOiBzdHJpbmc7XG4gIHRvOiBzdHJpbmc7XG4gIHJvdXRlPzogc3RyaW5nO1xuICB0aW1lOiBudW1iZXI7XG4gIGRpc3RhbmNlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBsYW5uZWRSb3V0ZSB7XG4gIGVzdGltYXRlZFRpbWU6IG51bWJlcjtcbiAgdHJhbnNmZXJzOiBudW1iZXI7XG4gIHN0ZXBzOiBSb3V0ZVN0ZXBbXTtcbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nW107IC8vIEFJLWdlbmVyYXRlZCBuYXZpZ2F0aW9uIGluc3RydWN0aW9uc1xuICB3YWxraW5nRGlzdGFuY2U/OiBudW1iZXI7XG4gIHJvdXRlSWRzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBjb25zdCByb3V0ZUFwaSA9IHtcbiAgLyoqXG4gICAqIFBsYW4gYSByb3V0ZSBmcm9tIGNvb3JkaW5hdGVzXG4gICAqL1xuICBwbGFuUm91dGU6IGFzeW5jIChyZXF1ZXN0OiBQbGFuUm91dGVSZXF1ZXN0KTogUHJvbWlzZTxQbGFubmVkUm91dGU+ID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdDxQbGFubmVkUm91dGU+KCcvcm91dGUvcGxhbicsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCByb3V0ZSBieSBzdG9wIElEc1xuICAgKi9cbiAgZ2V0Um91dGVCeVN0b3BzOiBhc3luYyAoXG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgcHJlZmVyZW5jZT86ICdmYXN0ZXN0JyB8ICdsZWFzdC13YWxraW5nJyB8ICdsZWFzdC10cmFuc2ZlcnMnLFxuICApOiBQcm9taXNlPFBsYW5uZWRSb3V0ZT4gPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgLi4uKHByZWZlcmVuY2UgJiYgeyBwcmVmZXJlbmNlIH0pLFxuICAgIH0pO1xuICAgIHJldHVybiBhcGlSZXF1ZXN0PFBsYW5uZWRSb3V0ZT4oYC9yb3V0ZS9yb3V0ZXM/JHtwYXJhbXN9YCk7XG4gIH0sXG59O1xuXG4vKipcbiAqIFN0b3BzIEFQSVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0b3Age1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGxpbmU/OiBzdHJpbmcgfCBudWxsO1xuICBsYXRpdHVkZTogbnVtYmVyO1xuICBsb25naXR1ZGU6IG51bWJlcjtcbiAgdHlwZTogJ0JVUycgfCAnVFJBSU4nIHwgJ01FVFJPJyB8ICdXQUxLSU5HJztcbiAgaXNTdGF0aW9uOiBib29sZWFuO1xuICBkaXN0YW5jZV9tPzogbnVtYmVyOyAvLyBBZGRlZCBieSBuZWFyZXN0IHF1ZXJ5XG59XG5cbmV4cG9ydCBjb25zdCBzdG9wc0FwaSA9IHtcbiAgLyoqXG4gICAqIEdldCBhbGwgc3RvcHNcbiAgICovXG4gIGdldEFsbDogYXN5bmMgKCk6IFByb21pc2U8U3RvcFtdPiA9PiB7XG4gICAgcmV0dXJuIGFwaVJlcXVlc3Q8U3RvcFtdPignL3N0b3BzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBzdG9wIGJ5IElEXG4gICAqL1xuICBnZXRCeUlkOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8U3RvcCB8IG51bGw+ID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdDxTdG9wIHwgbnVsbD4oYC9zdG9wcy8ke2lkfWApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIG5lYXJlc3Qgc3RvcHNcbiAgICovXG4gIGZpbmROZWFyZXN0OiBhc3luYyAoXG4gICAgbGF0OiBudW1iZXIsXG4gICAgbG5nOiBudW1iZXIsXG4gICAgcmFkaXVzOiBudW1iZXIgPSA1MDAsXG4gICAgbGltaXQ6IG51bWJlciA9IDEwLFxuICApOiBQcm9taXNlPFN0b3BbXT4gPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgbmVhcjogYCR7bGF0fSwke2xuZ31gLFxuICAgICAgcmFkaXVzOiByYWRpdXMudG9TdHJpbmcoKSxcbiAgICAgIGxpbWl0OiBsaW1pdC50b1N0cmluZygpLFxuICAgIH0pO1xuICAgIHJldHVybiBhcGlSZXF1ZXN0PFN0b3BbXT4oYC9zdG9wcz8ke3BhcmFtc31gKTtcbiAgfSxcbn07XG5cbi8qKlxuICogUm91dGVzIEFQSVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBsaW5lPzogc3RyaW5nIHwgbnVsbDtcbiAgdHJhbnNwb3J0VHlwZTogJ0JVUycgfCAnVFJBSU4nIHwgJ01FVFJPJztcbiAgY29sb3I/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgY29uc3Qgcm91dGVzQXBpID0ge1xuICAvKipcbiAgICogR2V0IGFsbCByb3V0ZXNcbiAgICovXG4gIGdldEFsbDogYXN5bmMgKCk6IFByb21pc2U8Um91dGVbXT4gPT4ge1xuICAgIHJldHVybiBhcGlSZXF1ZXN0PFJvdXRlW10+KCcvcm91dGVzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCByb3V0ZSBieSBJRCB3aXRoIHN0b3BzXG4gICAqL1xuICBnZXRCeUlkOiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8Um91dGUgJiB7IHJvdXRlU3RvcHM6IGFueVtdIH0+ID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdDxSb3V0ZSAmIHsgcm91dGVTdG9wczogYW55W10gfT4oYC9yb3V0ZXMvJHtpZH1gKTtcbiAgfSxcbn07XG5cbi8qKlxuICogSGVhbHRoIGNoZWNrXG4gKi9cbmV4cG9ydCBjb25zdCBoZWFsdGhBcGkgPSB7XG4gIGNoZWNrOiBhc3luYyAoKTogUHJvbWlzZTx7IHN0YXR1czogc3RyaW5nOyB0aW1lc3RhbXA6IHN0cmluZzsgc2VydmljZTogc3RyaW5nIH0+ID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdCgnL2hlYWx0aCcpO1xuICB9LFxufTtcblxuLyoqXG4gKiBHZXQgYXV0aCB0b2tlbiBmcm9tIGxvY2FsU3RvcmFnZVxuICovXG5mdW5jdGlvbiBnZXRBdXRoVG9rZW4oKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gIC8vIENoZWNrIGJvdGggcG9zc2libGUga2V5cyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc1Rva2VuJykgfHwgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhfdG9rZW4nKTtcbn1cblxuLyoqXG4gKiBBdXRoZW50aWNhdGVkIEFQSSByZXF1ZXN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0PFQ+KFxuICBlbmRwb2ludDogc3RyaW5nLFxuICBvcHRpb25zPzogUmVxdWVzdEluaXQsXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcbiAgcmV0dXJuIGFwaVJlcXVlc3Q8VD4oZW5kcG9pbnQsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAuLi4odG9rZW4gJiYgeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9KSxcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBEYXNoYm9hcmQgQVBJXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkU3RhdHMge1xuICB0b3RhbFJvdXRlczogbnVtYmVyO1xuICB0b3RhbFJvdXRlc0NoYW5nZTogbnVtYmVyO1xuICBhdmdDb21tdXRlVGltZTogbnVtYmVyO1xuICBhdmdDb21tdXRlVGltZUNoYW5nZTogbnVtYmVyO1xuICBmYXZvcml0ZVRyYW5zcG9ydDogc3RyaW5nO1xuICBmYXZvcml0ZVRyYW5zcG9ydENvdW50OiBudW1iZXI7XG4gIHRpbWVTYXZlZEhvdXJzOiBzdHJpbmc7XG4gIHJlY2VudFJvdXRlczogQXJyYXk8e1xuICAgIGlkOiBzdHJpbmc7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHRvOiBzdHJpbmc7XG4gICAgZGF0ZTogc3RyaW5nO1xuICAgIGR1cmF0aW9uOiBzdHJpbmc7XG4gIH0+O1xufVxuXG5leHBvcnQgY29uc3QgZGFzaGJvYXJkQXBpID0ge1xuICAvKipcbiAgICogR2V0IHVzZXIgZGFzaGJvYXJkIHN0YXRpc3RpY3NcbiAgICovXG4gIGdldFN0YXRzOiBhc3luYyAoKTogUHJvbWlzZTxEYXNoYm9hcmRTdGF0cz4gPT4ge1xuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdDxEYXNoYm9hcmRTdGF0cz4oJy9kYXNoYm9hcmQvc3RhdHMnKTtcbiAgfSxcbn07XG5cbi8qKlxuICogU2F2ZWQgUm91dGVzIEFQSVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNhdmVkUm91dGUge1xuICBpZDogc3RyaW5nO1xuICBzdGFydFN0b3BJZDogc3RyaW5nO1xuICBlbmRTdG9wSWQ6IHN0cmluZztcbiAgcm91dGVJZHM6IHN0cmluZ1tdO1xuICBldGFNaW51dGVzOiBudW1iZXI7XG4gIHN0ZXBzSnNvbjogc3RyaW5nO1xuICBwcmVmZXJlbmNlPzogc3RyaW5nO1xuICB3YWxraW5nRGlzdGFuY2VNPzogbnVtYmVyO1xuICB0cmFuc2ZlcnNDb3VudD86IG51bWJlcjtcbiAgc2F2ZWROYW1lPzogc3RyaW5nO1xuICBzdGFydFN0b3A6IHsgbmFtZTogc3RyaW5nIH07XG4gIGVuZFN0b3A6IHsgbmFtZTogc3RyaW5nIH07XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3Qgc2F2ZWRSb3V0ZXNBcGkgPSB7XG4gIC8qKlxuICAgKiBHZXQgdXNlcidzIHNhdmVkIHJvdXRlc1xuICAgKi9cbiAgZ2V0QWxsOiBhc3luYyAoKTogUHJvbWlzZTxTYXZlZFJvdXRlW10+ID0+IHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3Q8U2F2ZWRSb3V0ZVtdPignL3JvdXRlcy9zYXZlZC9hbGwnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2F2ZSBhIHJvdXRlXG4gICAqL1xuICBzYXZlOiBhc3luYyAocm91dGVEYXRhOiB7XG4gICAgc3RhcnRTdG9wSWQ6IHN0cmluZztcbiAgICBlbmRTdG9wSWQ6IHN0cmluZztcbiAgICByb3V0ZUlkczogc3RyaW5nW107XG4gICAgZXRhTWludXRlczogbnVtYmVyO1xuICAgIHN0ZXBzSnNvbjogc3RyaW5nO1xuICAgIHByZWZlcmVuY2U/OiBzdHJpbmc7XG4gICAgd2Fsa2luZ0Rpc3RhbmNlTT86IG51bWJlcjtcbiAgICB0cmFuc2ZlcnNDb3VudD86IG51bWJlcjtcbiAgICBzYXZlZE5hbWU/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPFNhdmVkUm91dGU+ID0+IHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3Q8U2F2ZWRSb3V0ZT4oJy9yb3V0ZXMvc2F2ZScsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocm91dGVEYXRhKSxcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlIGEgc2F2ZWQgcm91dGVcbiAgICovXG4gIGRlbGV0ZTogYXN5bmMgKHJvdXRlSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdDx2b2lkPihgL3JvdXRlcy9zYXZlZC8ke3JvdXRlSWR9YCwge1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTWFyayByb3V0ZSBhcyBjb21wbGV0ZWRcbiAgICovXG4gIGNvbXBsZXRlOiBhc3luYyAocm91dGVJZDogc3RyaW5nLCBhY3R1YWxEdXJhdGlvbk1pbjogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0PHZvaWQ+KCcvcm91dGVzL2NvbXBsZXRlJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJvdXRlSWQsIGFjdHVhbER1cmF0aW9uTWluIH0pLFxuICAgIH0pO1xuICB9LFxufTtcblxuLyoqXG4gKiBPcHRpb25hbCBhdXRoZW50aWNhdGVkIHJlcXVlc3QgLSB3b3JrcyB3aXRoIG9yIHdpdGhvdXQgYXV0aCB0b2tlblxuICogVXNlZCBmb3IgZW5kcG9pbnRzIHRoYXQgc3VwcG9ydCBvcHRpb25hbCBhdXRoZW50aWNhdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBvcHRpb25hbEF1dGhlbnRpY2F0ZWRSZXF1ZXN0PFQ+KFxuICBlbmRwb2ludDogc3RyaW5nLFxuICBvcHRpb25zPzogUmVxdWVzdEluaXQsXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcbiAgcmV0dXJuIGFwaVJlcXVlc3Q8VD4oZW5kcG9pbnQsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAuLi4odG9rZW4gJiYgeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9KSxcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBHb29nbGUgTWFwcyBBUElcbiAqIE5vdGU6IGdlb2NvZGUgYW5kIGF1dG9jb21wbGV0ZSBzdXBwb3J0IG9wdGlvbmFsIGF1dGhlbnRpY2F0aW9uICh3b3JrIGZvciBndWVzdCB1c2VycylcbiAqL1xuZXhwb3J0IGNvbnN0IGdvb2dsZU1hcHNBcGkgPSB7XG4gIC8qKlxuICAgKiBHZW9jb2RlIGFkZHJlc3MgdG8gY29vcmRpbmF0ZXNcbiAgICogV29ya3Mgd2l0aCBvciB3aXRob3V0IGF1dGhlbnRpY2F0aW9uXG4gICAqL1xuICBnZW9jb2RlOiBhc3luYyAoXG4gICAgYWRkcmVzczogc3RyaW5nLFxuICAgIGdlb2NvZGVPcHRpb25zPzogeyBcbiAgICAgIGNvbXBvbmVudFJlc3RyaWN0aW9ucz86IHsgY291bnRyeTogc3RyaW5nIH07IFxuICAgICAgbG9jYXRpb25CaWFzPzogeyBjaXJjbGU6IHsgY2VudGVyOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9OyByYWRpdXM6IG51bWJlciB9IH0gXG4gICAgfVxuICApOiBQcm9taXNlPHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0+ID0+IHtcbiAgICAvLyBDb252ZXJ0IHRvIGJhY2tlbmQgZm9ybWF0XG4gICAgY29uc3QgYmFja2VuZE9wdGlvbnM6IGFueSA9IHsgYWRkcmVzcyB9O1xuICAgIGlmIChnZW9jb2RlT3B0aW9ucz8ubG9jYXRpb25CaWFzPy5jaXJjbGUpIHtcbiAgICAgIGJhY2tlbmRPcHRpb25zLmxvY2F0aW9uID0ge1xuICAgICAgICBsYXQ6IGdlb2NvZGVPcHRpb25zLmxvY2F0aW9uQmlhcy5jaXJjbGUuY2VudGVyLmxhdCxcbiAgICAgICAgbG5nOiBnZW9jb2RlT3B0aW9ucy5sb2NhdGlvbkJpYXMuY2lyY2xlLmNlbnRlci5sbmcsXG4gICAgICB9O1xuICAgICAgYmFja2VuZE9wdGlvbnMucmFkaXVzID0gZ2VvY29kZU9wdGlvbnMubG9jYXRpb25CaWFzLmNpcmNsZS5yYWRpdXM7XG4gICAgfVxuICAgIGlmIChnZW9jb2RlT3B0aW9ucz8uY29tcG9uZW50UmVzdHJpY3Rpb25zPy5jb3VudHJ5KSB7XG4gICAgICBiYWNrZW5kT3B0aW9ucy5jb21wb25lbnRzID0gYGNvdW50cnk6JHtnZW9jb2RlT3B0aW9ucy5jb21wb25lbnRSZXN0cmljdGlvbnMuY291bnRyeX1gO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3B0aW9uYWxBdXRoZW50aWNhdGVkUmVxdWVzdDx7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9PignL2dvb2dsZS1tYXBzL2dlb2NvZGUnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJhY2tlbmRPcHRpb25zKSxcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV2ZXJzZSBnZW9jb2RlIGNvb3JkaW5hdGVzIHRvIGFkZHJlc3NcbiAgICogV29ya3Mgd2l0aCBvciB3aXRob3V0IGF1dGhlbnRpY2F0aW9uXG4gICAqL1xuICByZXZlcnNlR2VvY29kZTogYXN5bmMgKGxhdDogbnVtYmVyLCBsbmc6IG51bWJlcik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3B0aW9uYWxBdXRoZW50aWNhdGVkUmVxdWVzdDx7IGFkZHJlc3M6IHN0cmluZyB9PignL2dvb2dsZS1tYXBzL3JldmVyc2UtZ2VvY29kZScsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBsYXQsIGxuZyB9KSxcbiAgICB9KTtcbiAgICByZXR1cm4gKHJlc3VsdCBhcyBhbnkpLmFkZHJlc3MgfHwgJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBwbGFjZSBhdXRvY29tcGxldGUgc3VnZ2VzdGlvbnNcbiAgICogV29ya3Mgd2l0aCBvciB3aXRob3V0IGF1dGhlbnRpY2F0aW9uXG4gICAqL1xuICBhdXRvY29tcGxldGU6IGFzeW5jIChcbiAgICBpbnB1dDogc3RyaW5nLCBcbiAgICBzZXNzaW9uVG9rZW4/OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIGNvbXBvbmVudFJlc3RyaWN0aW9ucz86IHsgY291bnRyeTogc3RyaW5nIH07XG4gICAgICBsb2NhdGlvbkJpYXM/OiB7IGNpcmNsZTogeyBjZW50ZXI6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH07IHJhZGl1czogbnVtYmVyIH0gfTtcbiAgICB9XG4gICk6IFByb21pc2U8YW55W10+ID0+IHtcbiAgICAvLyBDb252ZXJ0IHRvIGJhY2tlbmQgZm9ybWF0XG4gICAgY29uc3QgYmFja2VuZE9wdGlvbnM6IGFueSA9IHt9O1xuICAgIGlmIChvcHRpb25zPy5sb2NhdGlvbkJpYXM/LmNpcmNsZSkge1xuICAgICAgYmFja2VuZE9wdGlvbnMubG9jYXRpb24gPSB7XG4gICAgICAgIGxhdDogb3B0aW9ucy5sb2NhdGlvbkJpYXMuY2lyY2xlLmNlbnRlci5sYXQsXG4gICAgICAgIGxuZzogb3B0aW9ucy5sb2NhdGlvbkJpYXMuY2lyY2xlLmNlbnRlci5sbmcsXG4gICAgICB9O1xuICAgICAgYmFja2VuZE9wdGlvbnMucmFkaXVzID0gb3B0aW9ucy5sb2NhdGlvbkJpYXMuY2lyY2xlLnJhZGl1cztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LmNvbXBvbmVudFJlc3RyaWN0aW9ucz8uY291bnRyeSkge1xuICAgICAgYmFja2VuZE9wdGlvbnMuY29tcG9uZW50cyA9IGBjb3VudHJ5OiR7b3B0aW9ucy5jb21wb25lbnRSZXN0cmljdGlvbnMuY291bnRyeX1gO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3B0aW9uYWxBdXRoZW50aWNhdGVkUmVxdWVzdDxhbnlbXT4oJy9nb29nbGUtbWFwcy9hdXRvY29tcGxldGUnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW5wdXQsIHNlc3Npb25Ub2tlbiwgLi4uYmFja2VuZE9wdGlvbnMgfSksXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBkaXJlY3Rpb25zL3JvdXRlXG4gICAqIFJlcXVpcmVzIGF1dGhlbnRpY2F0aW9uXG4gICAqL1xuICBnZXREaXJlY3Rpb25zOiBhc3luYyAoXG4gICAgb3JpZ2luOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9LFxuICAgIGRlc3RpbmF0aW9uOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9LFxuICAgIHdheXBvaW50cz86IEFycmF5PHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0+LFxuICApOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdDxhbnk+KCcvZ29vZ2xlLW1hcHMvZGlyZWN0aW9ucycsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBvcmlnaW4sIGRlc3RpbmF0aW9uLCB3YXlwb2ludHMgfSksXG4gICAgfSk7XG4gIH0sXG59O1xuXG4vKipcbiAqIEFQSSBVc2FnZSBBUElcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcGlVc2FnZVN0YXRzIHtcbiAgaXNQcmVtaXVtOiBib29sZWFuO1xuICB1c2FnZToge1xuICAgIGR5bmFtaWNNYXBzOiB7IGN1cnJlbnQ6IG51bWJlcjsgbGltaXQ6IG51bWJlcjsgcGVyY2VudGFnZTogbnVtYmVyIH07XG4gICAgcGxhY2VzQXV0b2NvbXBsZXRlOiB7IGN1cnJlbnQ6IG51bWJlcjsgbGltaXQ6IG51bWJlcjsgcGVyY2VudGFnZTogbnVtYmVyIH07XG4gICAgZGlyZWN0aW9uczogeyBjdXJyZW50OiBudW1iZXI7IGxpbWl0OiBudW1iZXI7IHBlcmNlbnRhZ2U6IG51bWJlciB9O1xuICAgIGdlb2NvZGluZzogeyBjdXJyZW50OiBudW1iZXI7IGxpbWl0OiBudW1iZXI7IHBlcmNlbnRhZ2U6IG51bWJlciB9O1xuICAgIHN0YXRpY01hcHM6IHsgY3VycmVudDogbnVtYmVyOyBsaW1pdDogbnVtYmVyOyBwZXJjZW50YWdlOiBudW1iZXIgfTtcbiAgICBsYXN0UmVzZXRBdDogc3RyaW5nO1xuICB9IHwgbnVsbDtcbn1cblxuZXhwb3J0IGNvbnN0IGFwaVVzYWdlQXBpID0ge1xuICAvKipcbiAgICogR2V0IHVzZXIncyBBUEkgdXNhZ2Ugc3RhdGlzdGljc1xuICAgKi9cbiAgZ2V0VXNhZ2U6IGFzeW5jICgpOiBQcm9taXNlPEFwaVVzYWdlU3RhdHM+ID0+IHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3Q8QXBpVXNhZ2VTdGF0cz4oJy9hcGktdXNhZ2UnKTtcbiAgfSxcbn07XG5cbiJdLCJuYW1lcyI6WyJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwibG9jYXRpb24iLCJtZXNzYWdlIiwiZGF0YSIsImFwaUJhc2VVcmwiLCJlbnZWYXIiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93Iiwic2Vzc2lvbklkIiwicnVuSWQiLCJoeXBvdGhlc2lzSWQiLCJjYXRjaCIsIkFwaUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInN0YXR1cyIsInJlc3BvbnNlIiwibmFtZSIsImFwaVJlcXVlc3QiLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJ1cmwiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJzdGF0dXNUZXh0IiwiY29udGVudFR5cGUiLCJnZXQiLCJpbmNsdWRlcyIsImVycm9yIiwicm91dGVBcGkiLCJwbGFuUm91dGUiLCJyZXF1ZXN0IiwiZ2V0Um91dGVCeVN0b3BzIiwiZnJvbSIsInRvIiwicHJlZmVyZW5jZSIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInN0b3BzQXBpIiwiZ2V0QWxsIiwiZ2V0QnlJZCIsImlkIiwiZmluZE5lYXJlc3QiLCJsYXQiLCJsbmciLCJyYWRpdXMiLCJsaW1pdCIsIm5lYXIiLCJ0b1N0cmluZyIsInJvdXRlc0FwaSIsImhlYWx0aEFwaSIsImNoZWNrIiwiZ2V0QXV0aFRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImF1dGhlbnRpY2F0ZWRSZXF1ZXN0IiwidG9rZW4iLCJBdXRob3JpemF0aW9uIiwiZGFzaGJvYXJkQXBpIiwiZ2V0U3RhdHMiLCJzYXZlZFJvdXRlc0FwaSIsInNhdmUiLCJyb3V0ZURhdGEiLCJkZWxldGUiLCJyb3V0ZUlkIiwiY29tcGxldGUiLCJhY3R1YWxEdXJhdGlvbk1pbiIsIm9wdGlvbmFsQXV0aGVudGljYXRlZFJlcXVlc3QiLCJnb29nbGVNYXBzQXBpIiwiZ2VvY29kZSIsImFkZHJlc3MiLCJnZW9jb2RlT3B0aW9ucyIsImJhY2tlbmRPcHRpb25zIiwibG9jYXRpb25CaWFzIiwiY2lyY2xlIiwiY2VudGVyIiwiY29tcG9uZW50UmVzdHJpY3Rpb25zIiwiY291bnRyeSIsImNvbXBvbmVudHMiLCJyZXZlcnNlR2VvY29kZSIsInJlc3VsdCIsImF1dG9jb21wbGV0ZSIsImlucHV0Iiwic2Vzc2lvblRva2VuIiwiZ2V0RGlyZWN0aW9ucyIsIm9yaWdpbiIsImRlc3RpbmF0aW9uIiwid2F5cG9pbnRzIiwiYXBpVXNhZ2VBcGkiLCJnZXRVc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});